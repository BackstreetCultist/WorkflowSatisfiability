\documentclass[11pt]{article}
\usepackage{geometry}
\usepackage{cite}
\usepackage{amsfonts}
\usepackage{amsmath}
\geometry{a4paper, margin=2.5cm}

\title{Knowledge Representation and Reasoning Formal Excercise Six Report}
\author{Charlie Wilkins}
\date{\today}

\begin{document}
	\begin{titlepage}
		\begin{center}
			\vspace*{1cm}

       		\textbf{Knowledge Representation and Reasoning}

       		\vspace{0.5cm}

			   Coursework - Workflow Satisfiability Problem

       		\vspace{1.5cm}

       		Charlie Wilkins
			
			\vspace{0.5cm}			
			
       		psychw@nottingham.ac.uk
       		
       		14322520
       		
       		\vspace{0.5cm}
       		
       		\today
		\end{center}
	\end{titlepage}

	\begin{abstract}

		I develop a CSP-Solver for the Workflow Satisfiability Problem in Python
		using OR-Tools, an optimisation-problem library developed by Google. I
		briefly introduce the problem and discuss related research before providing
		a mathematical description of the Solver's operations. There then follows
		discussion of the implementation of the Solver and its performance.

	\end{abstract}

	\newpage

	\tableofcontents

	\newpage

	\section{Introduction}

		The Workflow Satisfiability Problem (WSP) is defined by Crampton et. al\cite{crampton16} as
		"the problem of determining whether there exists an assignment of
		users to workflow steps that satisfies the policy", where the "policy"
		is a set of access-control rules dictating which users can be assigned
		to which steps. The WSP is notable for its ability to model real-world
		scenarios involving workflow scheduling\cite{crampton16}. It is known to be NP-Hard\cite{crampton162}, and NP-Complete in the case that
		certain constraints are included (including the Separation-of-Duty constraint
		modelled here)\cite{wang10}.

		OR-Tools is "an open source software suite for optimization"\footnote{Taken from Google's official page for the software here: https://developers.google.com/optimization}
		implemented as a library in multiple programming languages including Python.
		Crucially, the library offers a module known as the CP-SAT Solver intended for
		use in Constraint Programming (CP). Given that the WSP is provably tractable to
		CP\cite{benoist02}, the CP-SAT Solver is highly applicable in this case.

		As such, this study focuses on the implementation of a solver for the WSP
		in Python using the CP-SAT Solver provided by the OR-Tools suite. Python
		was chosen due to existing knowledge of the library in this language,
		as well as due to the specification of the problem in this case requiring
		complex string manipulation to generate problem instances - Python is
		known to be an effective and well-documented language for string
		manipulation\footnote{See e.g. https://towardsdatascience.com/tips-for-string-manipulation-in-python-92b1fc3f4d9f}.

		The study finds that a solver can be created using Python and CP-SAT that
		is effective at handling all five of the constraints specified in this case (see Formulation section)
		without any known flaws or errors, and is capable of determining whether
		the initially-found solution (if there is one) is unique. However, the
		system struggles with large problem instances, to the point of failing to
		terminate after half-an-hour or more in some cases. The cause of this is
		fairly well-understood (see Evaluation section), however it is a key limitation
		which would surely need to be fixed as a matter of priority were work on
		the system to continue.

	\section{Formulation}

		The specification of WSP in this case called for five constraints to be implemented.
		Here, we will discuss each of these constraints in turn, giving the mathematical
		formulation used as well as some acknowledgement of how it was implemented in the
		Python program.

		The specification also called for the problem to be able to tell if the solution
		it had found (in the case that it had judged the problem instance \(sat\)) was
		unique or not. This will be discussed in the final part of this section.

		At the heart of the solver are two sets of variables and an assignment:

		\begin{itemize}
			\item The set \(S = \{s_1, s_2... s_n\}\) of steps or tasks to be assigned.
			\item The set \(U = \{u_1, u_2... u_n\}\) of users to whom steps can be assigned.
			\item The assignment \(\pi : S \rightarrow U\) of steps to users, e.g. \(\pi(s_1) = u_1\) denotes that the step \(s_1\) is assigned to the user \(u_1\).\footnote{Note that in the program, this is represented by the array \(assignment[]\), e.g. \(assignment[0]=1\)} We can say that a problem instance is \(sat\) if there exists a valid assignment \(\pi(s)\) for all \(s \in S\).
		\end{itemize}

		With that defined, we can move on to discuss the formulation of each constraint.

		\subsection{Authorisation}

			An Authorisation constraint consists of a user \(u \in U\) and an authorisation list \(A \subseteq S\).
			It states that \(u\) is only permitted to perform tasks in \(A\).
			This is implemented in the solver according to the following mathematical formula:

			\begin{equation}
				\pi(s) \neq u \qquad \qquad \qquad \qquad u \in U, \forall s \notin A, A \subseteq S
			\end{equation}

			Quite simply, we add a constraint for every step \(s\) that is \textbf{not} in the authorisation list \(A\)
			stating that the user \(u\) cannot be assigned that step.

		\subsection{Binding of Duty}

			An instance of the Binding of Duty constraint supplies two steps \(s_1\) and \(s_2\),
			and states that they must be carried out by the same user.
			This is formulated simply, like so:

			\begin{equation}
				\pi(s_1) = \pi(s_2) \qquad \qquad \qquad \qquad s_1, s_2 \in S
			\end{equation}

			In plain language, the assignments of \(s_1\) and \(s_2\) must be the same.

		\subsection{Separation of Duty}

			Separation of Duty is, essentially, the opposite to Binding of Duty:
			given two steps \(s_1\) and \(s_2\),
			their assignment must be different:

			\begin{equation}
				\pi(s_1) \neq \pi(s_2) \qquad \qquad \qquad \qquad s_1, s_2 \in S
			\end{equation}

			Again in plain language, the assignments of \(s_1\) and \(s_2\) must be different.

		\subsection{At-Most-\(k\)}

			At-Most-\(k\) is a constraint stating that for a set of steps \(T \subseteq S\),
			the maximum amount of users assigned must be no more than \(k\),
			in other words, the size of the "team" working on \(T\) can be no bigger than \(k\).
			This can be expressed using set cardinatlity:

			\begin{multline}
				uniqueUsers(T) <= k\\
				where \ uniqueUsers(T) = |removeDuplicates(X)|\\
				where \ X = \pi(t)\forall t \in T \qquad k \in \mathbb{N}, T \subseteq S
			\end{multline}
			
			In other words, \(uniqueUsers()\) returns the amount of unique users in \(U\) assigned to a subset of \(S\).
			This proved somewhat more difficult to implement in OR-Tools,
			due to the fact that most operations are not evaluated at "solve-time"
			i.e. the moment that the solver is called. For example, the code snippet...

			\begin{align*}
				&len(set([1,2,3,1]))
			\end{align*}

			...which normally would return \(3\), will not work if called on CP-SAT variables.

			As such, what is used in the program is a Boolean CP-SAT variable stating whether or not,
			for each user, they are assigned to a task in the given subset.
			Additionally to this, linking users to tasks in this way require "constraint channeling"\footnote{https://developers.google.com/optimization/cp/channeling},
			forcing the creation of more arbitrary variables.
			
			The operation of the solver on this constraint is mathematically very similar to the formula given above,
			as since True Booleans in a set can be "counted" in Python,
			we are able to effectively "mock" the \(uniqueUsers()\) function and arrive at the same value.
			However, the large amount of variables created by this method is likely one cause of the system's poor performance (see Evaluation section).

		\subsection{One-Team}

			The One-Team constraint is the most complex of the constraints the solver implements.
			Provided is a set of steps followed by an arbitrary number of sets of users,
			known as "teams", with the constraint being that all the given steps must be carried out
			by members of the same team. In other words, given the steps \(s_1\) and \(s_2\),
			and the teams \(\{u_1, u_2\}\) and \(\{u_3, u_4\}\),
			\(\pi(s_1) = u_3\) and \(\pi(s_2) = u_4\) is a valid assignment, but \(\pi(s_1) = u_1\) and \(\pi(s_2) = u_3\) is not.

			\begin{multline}
				\exists x' \in X . x' = true \\ where \ \forall x \in X, \forall T \in Ts, x = AllInTeam(S', T) \qquad S' \subseteq S, (\forall T \in Ts) \subseteq U, |Ts| = |X|
			\end{multline}

			Simply, we create a Boolean variable \(x\) for each team, whose value is set by some predicate \(AllInTeam()\),
			which returns true if all of a given set of steps are assigned to members of a given set of users.
			If at least one such \(x\) is true, then we can say that the specified steps have been assigned to one of the specified teams.

			However, this constraint once again proves much harder to implement using OR-Tools than to specify mathematically.
			Once again, the issue can be found in the lack of possible operations in OR-Tools -
			Python provides the powerful \(in\) keyword to test if an element is in a list,
			so an easy solution might seem to run something like this:

			\begin{align*}
				&allInTeams = [] \\
				&for \ team \ in \ teams:\\
				&\qquad stepsInTeam = [(step \ in \ team) \ for \ step \ in \ steps]\\
				&\qquad allInTeam = (stepsInTeam == len(steps))\\
				&\qquad allInTeams.append(allInTeam)
			\end{align*}

			However, the \(in\) keyword cannot be used at solve-time with OR-Tools.
			As such, the implementation of the \(Allinteam\) predicate and the building of the \(X\) set
			once again required costly use of extra Boolean variables due to constraint channeling and
			a requirement to check individual tasks against individual team members.

		\subsection{Solution Uniqueness}

			The final operation that requires mathematical expression is not strictly a constraint,
			however it was an optional requirement of the solver.
			Namely, that the solver was able to determine whether or not a solution was unique.
			This determination is carried out by adding a new constraint to the solver:

			\begin{equation}
				\exists s. \pi(s) \neq \pi'(s) \qquad \qquad \qquad \qquad s \in S
			\end{equation}

			Where \(\pi\) represents the original set of assignments, and \(\pi'\) represents an arbitrary new set.
			Thus, there must be at least one different assignment for \(\pi'\) to be valid and therefore
			for a different solution to exist. If the output after adding this constraint is \(unsat\),
			then we know that the original solution was unique.

	\section{Implementation}

		As has been discussed elsewhere, the solver is implemented in Python using OR-Tools.
		OR-Tools requires Python3 specifically, so this must be installed.
		OR-Tools can then be installed via pip, and the program can be run normally,
		taking as a command-line argument a target file to solve.

		The source code appears twice in the repository,
		once under the src/ directory and once in CourseworkTester/.
		When run from src/, it will locate the specified problem instance in the instances/ directory -
		this functionality is removed in the other directory for compatability with the provided testing script.
		For more details, view the included README.md file.

		As explained in the above Section, the solver completes all the requirements listed, including the one to test whether a solution is unique.
		It fulfils this by re-running the solver, with an additional constraint that at least one assignment is different to the ones originally provided.
		Thus, if this proves \(unsat\), a second solution does not exist.

		There are no known bugs in the solver, and when run with the provided testing script no tests fail.
		However, its performance is far from perfect.
		The solver struggles to solve difficult instances, in some cases failing to terminate after half-an-hour or longer.
		The likely reasons for this will be discussed in the following Section.

	\section{Evaluation}

	\section{Conclusions \& Future Work}

		% Talk about FPT

		% Talk about multithreading

	\section{References}
	\bibliography{bibliography}
	\bibliographystyle{plain}

\end{document}
